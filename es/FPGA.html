<!DOCTYPE html>
<html lang="es">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>FPGA & Digital Systems Design Portfolio - Simón Aulet</title>
      <link rel="stylesheet" href="../style.css">
      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
      <link rel="icon" href="../favicon.svg" type="image/svg+xml">
      <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
      <!-- Prism.js para syntax highlighting -->
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-verilog.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
  </head>
<body>
    <div class="container">
        <header>
            <h1>FPGA & Digital Systems Design Portfolio</h1>
            <p class="subtitle">Simón Aulet · Verilog · Artix-7 · Sistemas Digitales</p>
            <p class="description">Este repositorio compila una serie de proyectos de diseño lógico implementados en <strong>Verilog</strong> para la placa de desarrollo Artix-7. Los diseños abarcan desde lógica combinacional fundamental hasta máquinas de estados finitos (FSM) complejas e interactivas.</p>
            <div class="tech-tags">
                <span>FPGA</span>
                <span>Verilog</span>
                <span>Artix-7</span>
                <span>Sistemas Digitales</span>
                <span>FSM</span>
            </div>
            <div class="navigation">
                <a href="index.html" class="nav-link">← Volver al Portafolio Principal</a>
            </div>
        </header>

        <main>
            <div class="content-wrapper">
                <hr />
                <h2 id="sistema-de-alarma-de-3-estados">Sistema de Alarma de 3 Estados</h2>
                <p>Este proyecto implementa un sistema de control de seguridad residencial basado en una arquitectura de hardware síncrona. El núcleo del diseño es una máquina de estados finitos que administra tres modos de operación: Desarmado, Armado y Alarma Activa.</p>
                <blockquote>
                <p><strong>Código Fuente:</strong> <a href="https://github.com/SimonAulet/portfolio/tree/main/FPGA/Alarm"><code>https://github.com/SimonAulet/portfolio/tree/main/FPGA/Alarm</code></a></p>
                </blockquote>
                <div style="text-align: center; margin: 20px 0;">
                    <img src="../img/fpga.alarma_arch_transparent.png" alt="Arquitectura del Sistema de Alarma" style="max-width: 80%;">
                    <p><em>Arquitectura del sistema: flujo de señales entre la detección de secuencia y el control de estados.</em></p>
                </div>
                <h3 id="lógica-de-control-y-funcionamiento">Lógica de Control y Funcionamiento</h3>
                <p>La interfaz de usuario consta de tres pulsadores de combinación (<code>b1</code>, <code>b2</code>, <code>b3</code>) y un comando de validación (<code>check</code>). El sistema evalúa la secuencia ingresada únicamente cuando se presiona la validación, lo que permite una lógica de control robusta: si el usuario intenta validar una secuencia incorrecta mientras el sistema está armado, la transición es inmediata hacia el estado de Alarma. Del mismo modo, el estado de alerta se dispara ante la activación del sensor de movimiento (<code>MOV</code>).</p>
                <h3 id="estrategia-de-sincronización">Estrategia de Sincronización</h3>
                <p>Para garantizar la estabilidad operativa dentro de la FPGA y evitar la creación de múltiples dominios de reloj, se optó por una estrategia de habilitadores síncronos. En lugar de dividir la línea de reloj principal —con sus correspondientes problemas de timing— se implementó el módulo <code>freq_divider</code>.</p>
                <p>Este componente genera pulsos de un solo ciclo ("ticks") que habilitan procesos a frecuencias menores (como 1 kHz y 1 Hz), manteniendo todo el diseño perfectamente sincronizado al reloj maestro de 100 MHz. Además, el módulo es totalmente <strong>parametrizable</strong>, lo que permite ajustar las escalas de división para acelerar los tiempos en etapas de simulación o definir los valores finales para la síntesis.</p>
                <details>
                <summary>Ver Código: Generador de Ticks (freq_divider.v)</summary>
                <pre class="line-numbers"><code class="language-verilog">always @(posedge clk_in)
                  // Pulse generator at 1kHz and 1 Hz

                  module freq_divider #(
                    parameter mf_divider = 100_000,
                    parameter lf_divider = 1_000)
                  (
                  input  wire clk_in,
                  output reg  tick_mf,
                  output reg  tick_lf
                  );

                  reg [18:0] mf_counter;
                  reg [8:0] lf_counter;

                  initial
                  begin
                    tick_mf    = 0;
                    tick_lf    = 0;
                    mf_counter = 0;
                    lf_counter = 0;
                  end
                  // Counter advancing
                  always @(posedge clk_in)
                  begin
                    if (mf_counter == mf_divider - 1) //mf counter. division is for switching posedge and negedge
                    begin
                      mf_counter    <= 0;
                      if(lf_counter == lf_divider - 1) //lf counter
                        lf_counter  <= 0;
                      else
                        lf_counter <= lf_counter + 1;
                    end else begin
                      mf_counter   <= mf_counter + 1;
                    end
                  end

                  // Freq divider lf
                  always @(posedge clk_in)
                  begin
                    if((lf_counter == 0) && (mf_counter==0))
                      tick_lf <= 1'b1;
                    else
                      tick_lf <= 1'b0;
                  end
                  // Freq divider mf
                  always@(posedge clk_in)
                  begin
                    if(mf_counter == 0)
                      tick_mf <= 1'b1;
                    else
                      tick_mf <= 1'b0;
                  end
                  endmodule
                end
                </code></pre>
                </details>
                <h3 id="optimización-de-recursos">Optimización de Recursos</h3>
                <p>El acondicionamiento de las señales de entrada se beneficia directamente de la estrategia de sincronización anterior. El módulo <code>anti_bounce</code> utiliza los ticks de 1 kHz como referencia temporal para filtrar el ruido mecánico de los pulsadores. Esta decisión de diseño permite reducir significativamente el uso de registros: la ventana de estabilidad de 20 ms se gestiona con un contador compacto de 6 bits, evitando la necesidad de contadores de 21 bits que serían requeridos si se operara directamente sobre la frecuencia base de 100 MHz.</p>
                <h3 id="verificación">Verificación</h3>
                <p>La confiabilidad del sistema se aseguró mediante una metodología de validación incremental. Los módulos fueron sometidos a testbenches dedicados para verificar correcto funcionamiento antes de su integración final en la entidad superior.</p>
                <h2 id="secuenciador-de-luces-máquina-de-moore">Secuenciador de Luces (Máquina de Moore)</h2>
                <p>Este diseño implementa un secuenciador de efectos lumínicos controlado por un único pulsador. La arquitectura se basa estrictamente en el modelo de <strong>Máquina de Moore</strong>, donde las salidas dependen exclusivamente del estado actual y no de las entradas directas.</p>
                <blockquote>
                <p><strong>Código Fuente:</strong> <a href="https://github.com/SimonAulet/portfolio/tree/main/FPGA/Moore_seq"><code>https://github.com/SimonAulet/portfolio/tree/main/FPGA/Moore_seq</code></a></p>
                </blockquote>
                <h3 id="arquitectura-desacoplada">Arquitectura Desacoplada</h3>
                <p>Para maximizar la modularidad, se dividió el sistema en dos bloques funcionales independientes que operan bajo el mismo dominio de reloj (100 MHz), sincronizados mediante las señales de habilitación (<code>ticks</code>) heredadas del diseño anterior:</p>
                <ol type="1">
                <li><strong>Control de Estados (<code>state_change.v</code>):</strong> Gestiona la lectura del pulsador, el <em>debouncing</em> (usando <code>tick_mf</code>) y las transiciones de estados.</li>
                <li><strong>Decodificación de Salida (<code>led_change.v</code>):</strong> Interpreta el estado actual y genera los patrones visuales correspondientes.</li>
                </ol>
                <table>
                <tr>
                <td width="60%" valign="top">
                <h3>
                Lógica de Transición y Salida
                </h3>
                <p>
                El sistema cicla a través de 4 estados operativos con cada pulsación validada. La lógica de salida aprovecha la señal de baja frecuencia (<code>tick_lf</code> de 1 Hz) para generar efectos de parpadeo sin necesidad de contadores adicionales dentro del módulo de LEDs.
                </p>
                <ul>
                <li>
                <strong>Estado 00 (IDLE):</strong> Sistema en reposo, salidas apagadas.
                </li>
                <li>
                <strong>Estado 01:</strong> LED A parpadeando a 1 Hz.
                </li>
                <li>
                <strong>Estado 10:</strong> LED B parpadeando a 1 Hz.
                </li>
                <li>
                <strong>Estado 11:</strong> Ambos LEDs parpadeando sincronizados.
                </li>
                </ul>
                <p>
                Esta separación permite alterar los patrones lumínicos (ej: cambiar la frecuencia o el patrón de bit) modificando únicamente el módulo de salida, sin riesgo de alterar la lógica de control de flujo.
                </p>
                </td>
                <td width="40%" valign="top">
                <img src="../img/fpga.secuenciador_fsm.png" alt="Diagrama de Estados Secuenciador" width="100%">
                <p align="center">
                <em>Diagrama de estados del secuenciador (Moore)</em>
                </p>
                </td>
                </tr>
                </table>
                <details>
                <summary>
                Ver Código: Lógica de Salida (led_change.v)</summary>
                <pre class="line-numbers"><code class="language-verilog">module led_change(
                  input  wire[1:0] state,
                  input  wire      clk,
                  input  wire      tick_lf,
                  output reg       led_a,
                  output reg       led_b
                );

                initial
                begin
                  led_a = 1'b0;
                  led_b = 1'b0;
                end

                always@(posedge clk)
                  case(state)
                  2'b00:
                  begin
                    led_a <= 0;
                    led_b <= 0;
                  end
                  2'b01:
                  begin
                    if(tick_lf)
                      led_a <= ~led_a;
                    else
                      led_a <= led_a;
                    led_b <= 0;
                  end
                  2'b10:
                  begin
                    led_a <= 0;
                    if(tick_lf)
                      led_b <= ~led_b;
                    else
                      led_b <= led_b;
                  end
                  2'b11:
                  begin
                    if(tick_lf)
                      led_a <= ~led_a;
                    else
                      led_a <= led_a;
                      led_b <= led_a;  //copy led_a to avoid mirror blink
                  end
                  default:
                  begin
                    led_a <= 0;
                    led_b <= 0;
                  end
                endcase
                endmodule
                </code></pre>
                </details>
                <hr />
                <h2 id="fundamentos-de-verilog">Fundamentos de Verilog</h2>
                <p>Esta sección explora la construcción de hardware digital desde sus bloques más elementales, enfocándose en la modularidad, parametrización y máquinas de estados.</p>
                <blockquote>
                <p><strong>Código Fuente:</strong> <a href="https://github.com/SimonAulet/portfolio/tree/main/FPGA/Verilog"><code>https://github.com/SimonAulet/portfolio/tree/main/FPGA/Verilog</code></a></p>
                </blockquote>
                <table>
                <tr>
                <td width="40%" valign="top">
                <h3>
                Diseño Jerárquico: Sumador Completo (Ej. 10 y 11)
                </h3>
                <p>
                Este módulo ilustra la metodología de <strong>diseño "bottom-up"</strong>. En lugar de describir la lógica de suma completa de una vez, se construyó encapsulando componentes de menor nivel:
                </p>
                <ul>
                <li>
                <strong>Nivel 1 (Half Adder):</strong> Resuelve la suma de 1 bit sin acarreo de entrada.
                </li>
                <li>
                <strong>Nivel 2 (Full Adder):</strong> Instancia dos <em>Half Adders</em> y lógica de glue (OR) para gestionar el Acarreo (Carry).
                </li>
                </ul>
                <p>
                Esta estructura permite escalar fácilmente hacia un <strong>Sumador de 4-bits</strong> (Ripple Carry) reutilizando el módulo validado, base fundamental para la ALU.
                </p>
                </td>
                <td width="60%" valign="top">
                <img src="../img/fpga.fa_esquema.png" alt="Esquemático Full Adder" width="100%">
                <br>
                <p align="center">
                <em>Arquitectura con 2 Half-Adders</em>
                </p>
                <br> <img src="../img/fpga.fa_sim.png" alt="Simulación Full Adder" width="100%">
                <p align="center">
                <em>Validación de tabla de verdad</em>
                </p>
                </td>
                </tr>
                <tr>
                <td width="40%" valign="top">
                <h3>
                Unidad Aritmético Lógica (ALU) de 4-Bits (Ej. 12)
                </h3>
                <p>
                Integración de lógica combinacional aritmética y lógica en un solo núcleo. La ALU realiza 4 operaciones seleccionables mediante un <strong>Opcode</strong> de 2 bits:
                </p>
                <ul>
                <li>
                <strong>Suma (ADD):</strong> Utiliza el módulo <code>nibble_adder</code> derivado del ejercicio anterior.
                </li>
                <li>
                <strong>Resta (SUB):</strong> Implementa complemento a 2 invirtiendo el operando B y forzando el Carry-In.
                </li>
                <li>
                <strong>Lógica (AND / OR):</strong> Operaciones bit a bit.
                </li>
                </ul>
                <p>
                En las simulaciones se valida tanto el manejo de signo (formato decimal) como la operación bit a bit (formato binario).
                </p>
                </td>
                <td width="60%" valign="top">
                <img src="../img/fpga.alu_dec.png" alt="Simulación ALU Decimal" width="100%">
                <p align="center">
                <em>Aritmética: Suma y Resta (Signo)</em>
                </p>
                <br>
                <img src="../img/fpga.alu_bin.png" alt="Simulación ALU Binaria" width="100%">
                <p align="center">
                <em>Lógica: AND y OR (Bitwise)</em>
                </p>
                </td>
                </tr>
                <tr>
                <td width="40%" valign="top">
                <h3>
                Contador Parametrizable "Módulo-N" (Ej. 18)
                </h3>
                <p>
                Un diseño de lógica secuencial flexible que permite definir el límite de cuenta (N) diná</strong>micamente mediante una entrada de 8 bits. Se validaron 3 escenarios críticos:
                </p>
                <ul>
                <li>
                <strong>Inicio de Cuenta:</strong> Verificación del conteo básico ascendente desde 0 hasta N.
                </li>
                <li>
                <strong>Cambio Dinámico de N:</strong> Se modificó el valor de N durante la ejecución. El sistema adapta su comparador instantáneamente sin requerir un reset, continuando la cuenta hasta el nuevo límite.
                </li>
                <li>
                <strong>Reset Asíncrono:</strong> Verificación de la prioridad de la señal de reset, que fuerza la salida a 0 independientemente del reloj.
                </li>
                </ul>
                </td>
                <td width="60%" valign="top">
                <img src="../img/fpga.cnt_init.png" alt="Inicio del contador" width="100%">
                <p align="center">
                <em>1. Inicio de cuenta (0 a 5)</em>
                </p>
                <br> <img src="../img/fpga.cnt_change.png" alt="Cambio de modulo" width="100%">
                <p align="center">
                <em>2. Cambio de N "on-the-fly"</em>
                </p>
                <br> <img src="../img/fpga.cnt_reset.png" alt="Reset del contador" width="100%">
                <p align="center">
                <em>3. Reset Asíncrono</em>
                </p>
                </td>
                </tr>
                <tr>
                <td width="40%" valign="top">
                <h3>
                Detector de Secuencia "101" (Ej. 20)
                </h3>
                <p>
                Implementación de una <strong>Máquina de Estados de Moore</strong> que analiza una entrada serial bit a bit.
                </p>
                <p>
                Diseñado para permitir <strong>solapamiento</strong> (overlap). Por ejemplo, en la secuencia <code>10101</code>, el sistema activa la detección dos veces (el "1" final de la primera detección sirve como el "1" inicial de la siguiente), demostrando una lógica de control de flujo continua.
                </p>
                </td>
                <td width="60%" valign="top" style="text-align: center;">
                <img src="../img/fpga.detector101_fsm_transparent.png" alt="FSM Detector 101" width="70%">
                </td>
                </tr>
                </table>
                <hr />
            </div>
        </main>
        <div id="footer-container"></div>
    </div>
    <script>
            fetch('../components/footer-general_es.html')
                .then(response => response.text())
                .then(data => {
                    document.getElementById('footer-container').innerHTML = data;
                });
    </script>
</body>
</html>
