<!DOCTYPE html>
<html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>FPGA & Digital Systems Design Portfolio - Simón Aulet</title>
      <link rel="stylesheet" href="../style.css">
      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
      <link rel="icon" href="../favicon.svg" type="image/svg+xml">
      <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
      <!-- Prism.js para syntax highlighting -->
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-verilog.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
  </head>
<body>
    <div class="container">
        <header>
            <h1>FPGA & Digital Systems Design Portfolio</h1>
            <p class="subtitle">Simón Aulet · Verilog · Artix-7 · Digital Systems</p>
            <p class="description">This repository compiles a series of logic design projects implemented in <strong>Verilog</strong> for the Artix-7 development board. The designs range from fundamental combinational logic to complex and interactive finite state machines (FSM).</p>
            <div class="tech-tags">
                <span>FPGA</span>
                <span>Verilog</span>
                <span>Artix-7</span>
                <span>Digital Systems</span>
                <span>FSM</span>
            </div>
            <div class="navigation">
                <a href="index.html" class="nav-link">← Back to Main Portfolio</a>
            </div>
        </header>

        <main>
            <div class="content-wrapper">
                <hr />
                <h2 id="sistema-de-alarma-de-3-estados">3-State Alarm System</h2>
                <p>This project implements a residential security control system based on a synchronous hardware architecture. The core of the design is a finite state machine that manages three operation modes: Disarmed, Armed, and Active Alarm.</p>
                <blockquote>
                <p><strong>Source Code:</strong> <a href="https://github.com/SimonAulet/portfolio/tree/main/FPGA/Alarm"><code>https://github.com/SimonAulet/portfolio/tree/main/FPGA/Alarm</code></a></p>
                </blockquote>
                <div style="text-align: center; margin: 20px 0;">
                    <img src="../img/fpga.alarma_arch_transparent.png" alt="Arquitectura del Sistema de Alarma" style="max-width: 80%;">
                    <p><em>System architecture: signal flow between sequence detection and state control.</em></p>
                </div>
                <h3 id="lógica-de-control-y-funcionamiento">Control Logic and Operation</h3>
                <p>The user interface consists of three combination buttons (<code>b1</code>, <code>b2</code>, <code>b3</code>) and a validation command (<code>check</code>). The system evaluates the entered sequence only when validation is pressed, enabling robust control logic: if the user attempts to validate an incorrect sequence while the system is armed, the transition is immediate to the Alarm state. Similarly, the alert state triggers upon motion sensor activation (<code>MOV</code>).</p>
                <h3 id="estrategia-de-sincronización">Synchronization Strategy</h3>
                <p>To ensure operational stability within the FPGA and avoid creating multiple clock domains, a synchronous enable strategy was chosen. Instead of dividing the main clock line—with its corresponding timing issues—the <code>freq_divider</code> module was implemented.</p>
                <p>This component generates single-cycle pulses ("ticks") that enable processes at lower frequencies (such as 1 kHz and 1 Hz), keeping the entire design perfectly synchronized to the 100 MHz master clock. Additionally, the module is fully <strong>parameterizable</strong>, allowing adjustment of division scales to accelerate times during simulation stages or define final values for synthesis.</p>
                <details>
                <summary>View Code: Tick Generator (freq_divider.v)</summary>
                <pre class="line-numbers"><code class="language-verilog">always @(posedge clk_in)
                  // Pulse generator at 1kHz and 1 Hz

                  module freq_divider #(
                    parameter mf_divider = 100_000,
                    parameter lf_divider = 1_000)
                  (
                  input  wire clk_in,
                  output reg  tick_mf,
                  output reg  tick_lf
                  );

                  reg [18:0] mf_counter;
                  reg [8:0] lf_counter;

                  initial
                  begin
                    tick_mf    = 0;
                    tick_lf    = 0;
                    mf_counter = 0;
                    lf_counter = 0;
                  end
                  // Counter advancing
                  always @(posedge clk_in)
                  begin
                    if (mf_counter == mf_divider - 1) //mf counter. division is for switching posedge and negedge
                    begin
                      mf_counter    <= 0;
                      if(lf_counter == lf_divider - 1) //lf counter
                        lf_counter  <= 0;
                      else
                        lf_counter <= lf_counter + 1;
                    end else begin
                      mf_counter   <= mf_counter + 1;
                    end
                  end

                  // Freq divider lf
                  always @(posedge clk_in)
                  begin
                    if((lf_counter == 0) && (mf_counter==0))
                      tick_lf <= 1'b1;
                    else
                      tick_lf <= 1'b0;
                  end
                  // Freq divider mf
                  always@(posedge clk_in)
                  begin
                    if(mf_counter == 0)
                      tick_mf <= 1'b1;
                    else
                      tick_mf <= 1'b0;
                  end
                  endmodule
                end
                </code></pre>
                </details>
                <h3 id="optimización-de-recursos">Resource Optimization</h3>
                <p>Input signal conditioning directly benefits from the previous synchronization strategy. The <code>anti_bounce</code> module uses 1 kHz ticks as a temporal reference to filter mechanical noise from buttons. This design decision allows significant reduction in register usage: the 20 ms stability window is managed with a compact 6-bit counter, avoiding the need for 21-bit counters that would be required if operating directly on the 100 MHz base frequency.</p>
                <h3 id="verificación">Verification</h3>
                <p>System reliability was ensured through an incremental validation methodology. Modules were subjected to dedicated testbenches to verify correct operation before final integration into the top-level entity.</p>
                <h2 id="secuenciador-de-luces-máquina-de-moore">Light Sequencer (Moore Machine)</h2>
                <p>This design implements a light effect sequencer controlled by a single button. The architecture is strictly based on the <strong>Moore Machine</strong> model, where outputs depend exclusively on the current state and not on direct inputs.</p>
                <blockquote>
                <p><strong>Source Code:</strong> <a href="https://github.com/SimonAulet/portfolio/tree/main/FPGA/Sequencer"><code>https://github.com/SimonAulet/portfolio/tree/main/FPGA/Sequencer</code></a></p>
                </blockquote>
                <h3 id="arquitectura-desacoplada">Decoupled Architecture</h3>
                <p>To maximize modularity, the system was divided into two independent functional blocks operating under the same clock domain (100 MHz), synchronized through enable signals (<code>ticks</code>) inherited from the previous design:</p>
                <ol type="1">
                <li><strong>State Control (<code>state_change.v</code>):</strong> Manages button reading, debouncing (using <code>tick_mf</code>), and state transitions.</li>
                <li><strong>Output Decoding (<code>led_change.v</code>):</strong> Interprets the current state and generates corresponding visual patterns.</li>
                </ol>
                <table>
                <tr>
                <td width="60%" valign="top">
                <h3>
                Transition and Output Logic
                </h3>
                <p>
                The system cycles through 4 operational states with each validated button press. The output logic leverages the low-frequency signal (<code>tick_lf</code> at 1 Hz) to generate blinking effects without needing additional counters within the LED module.
                </p>
                <ul>
                <li>
                <strong>State 00 (IDLE):</strong> System at rest, outputs off.
                </li>
                <li>
                <strong>State 01:</strong> LED A blinking at 1 Hz.
                </li>
                <li>
                <strong>State 10:</strong> LED B blinking at 1 Hz.
                </li>
                <li>
                <strong>State 11:</strong> Both LEDs blinking synchronized.
                </li>
                </ul>
                <p>
                This separation allows altering light patterns (e.g., changing frequency or bit pattern) by modifying only the output module, without risk of altering the flow control logic.
                </p>
                </td>
                <td width="40%" valign="top">
                <img src="../img/fpga.secuenciador_fsm.png" alt="Sequencer State Diagram" width="100%">
                <p align="center">
                <em>Sequencer state diagram (Moore)</em>
                </p>
                </td>
                </tr>
                </table>
                <details>
                <summary>
                View Code: Output Logic (led_change.v)</summary>
                <pre class="line-numbers"><code class="language-verilog">module led_change(
                  input  wire[1:0] state,
                  input  wire      clk,
                  input  wire      tick_lf,
                  output reg       led_a,
                  output reg       led_b
                );

                initial
                begin
                  led_a = 1'b0;
                  led_b = 1'b0;
                end

                always@(posedge clk)
                  case(state)
                  2'b00:
                  begin
                    led_a <= 0;
                    led_b <= 0;
                  end
                  2'b01:
                  begin
                    if(tick_lf)
                      led_a <= ~led_a;
                    else
                      led_a <= led_a;
                    led_b <= 0;
                  end
                  2'b10:
                  begin
                    led_a <= 0;
                    if(tick_lf)
                      led_b <= ~led_b;
                    else
                      led_b <= led_b;
                  end
                  2'b11:
                  begin
                    if(tick_lf)
                      led_a <= ~led_a;
                    else
                      led_a <= led_a;
                      led_b <= led_a;  //copy led_a to avoid mirror blink
                  end
                  default:
                  begin
                    led_a <= 0;
                    led_b <= 0;
                  end
                endcase
                endmodule
                </code></pre>
                </details>
                <hr />
                <h2 id="fundamentos-de-verilog">Verilog Fundamentals</h2>
                <p>This section explores digital hardware construction from its most elementary blocks, focusing on modularity, parameterization, and state machines.</p>
                <blockquote>
                <p><strong>Source Code:</strong> <a href="https://github.com/SimonAulet/portfolio/tree/main/FPGA/Verilog"><code>https://github.com/SimonAulet/portfolio/tree/main/FPGA/Verilog</code></a></p>
                </blockquote>
                <table>
                <tr>
                <td width="40%" valign="top">
                <h3>
                Hierarchical Design: Full Adder (Ex. 10 and 11)
                </h3>
                <p>
                This module illustrates the <strong>"bottom-up" design methodology</strong>. Instead of describing the full adder logic at once, it was built by encapsulating lower-level components:
                </p>
                <ul>
                <li>
                <strong>Level 1 (Half Adder):</strong> Solves 1-bit addition without input carry.
                </li>
                <li>
                <strong>Level 2 (Full Adder):</strong> Instantiates two <em>Half Adders</em> and glue logic (OR) to manage the Carry.
                </li>
                </ul>
                <p>
                This structure allows easy scaling to a <strong>4-bit Adder</strong> (Ripple Carry) by reusing the validated module, fundamental basis for the ALU.
                </p>
                </td>
                <td width="60%" valign="top">
                <img src="../img/fpga.fa_esquema.png" alt="Full Adder Schematic" width="100%">
                <br>
                <p align="center">
                <em>Architecture with 2 Half-Adders</em>
                </p>
                <br> <img src="../img/fpga.fa_sim.png" alt="Full Adder Simulation" width="100%">
                <p align="center">
                <em>Truth table validation</em>
                </p>
                </td>
                </tr>
                <tr>
                <td width="40%" valign="top">
                <h3>
                4-Bit Arithmetic Logic Unit (ALU) (Ex. 12)
                </h3>
                <p>
                Integration of arithmetic and logical combinational logic in a single core. The ALU performs 4 selectable operations through a 2-bit <strong>Opcode</strong>:
                </p>
                <ul>
                <li>
                <strong>Addition (ADD):</strong> Uses the <code>nibble_adder</code> module derived from the previous exercise.
                </li>
                <li>
                <strong>Subtraction (SUB):</strong> Implements two's complement by inverting operand B and forcing Carry-In.
                </li>
                <li>
                <strong>Logic (AND / OR):</strong> Bitwise operations.
                </li>
                </ul>
                <p>
                Simulations validate both signed handling (decimal format) and bitwise operation (binary format).
                </p>
                </td>
                <td width="60%" valign="top">
                <img src="../img/fpga.alu_dec.png" alt="ALU Decimal Simulation" width="100%">
                <p align="center">
                <em>Arithmetic: Addition and Subtraction (Signed)</em>
                </p>
                <br>
                <img src="../img/fpga.alu_bin.png" alt="ALU Binary Simulation" width="100%">
                <p align="center">
                <em>Logic: AND and OR (Bitwise)</em>
                </p>
                </td>
                </tr>
                <tr>
                <td width="40%" valign="top">
                <h3>
                Parameterizable "Module-N" Counter (Ex. 18)
                </h3>
                <p>
                A flexible sequential logic design that allows defining the count limit (N) dynamically through an 8-bit input. Three critical scenarios were validated:
                </p>
                <ul>
                <li>
                <strong>Count Start:</strong> Verification of basic ascending count from 0 to N.
                </li>
                <li>
                <strong>Dynamic N Change:</strong> The N value was modified during execution. The system adapts its comparator instantly without requiring a reset, continuing the count to the new limit.
                </li>
                <li>
                <strong>Asynchronous Reset:</strong> Verification of reset signal priority, which forces output to 0 regardless of the clock.
                </li>
                </ul>
                </td>
                <td width="60%" valign="top">
                <img src="../img/fpga.cnt_init.png" alt="Counter Start" width="100%">
                <p align="center">
                <em>1. Count start (0 to 5)</em>
                </p>
                <br> <img src="../img/fpga.cnt_change.png" alt="Module Change" width="100%">
                <p align="center">
                <em>2. N change "on-the-fly"</em>
                </p>
                <br> <img src="../img/fpga.cnt_reset.png" alt="Counter Reset" width="100%">
                <p align="center">
                <em>3. Asynchronous Reset</em>
                </p>
                </td>
                </tr>
                <tr>
                <td width="40%" valign="top">
                <h3>
                "101" Sequence Detector (Ex. 20)
                </h3>
                <p>
                Implementation of a <strong>Moore State Machine</strong> that analyzes a serial input bit by bit.
                </p>
                <p>
                Designed to allow <strong>overlap</strong>. For example, in the sequence <code>10101</code>, the system activates detection twice (the final "1" of the first detection serves as the initial "1" of the next), demonstrating continuous flow control logic.
                </p>
                </td>
                <td width="60%" valign="top" style="text-align: center;">
                <img src="../img/fpga.detector101_fsm_transparent.png" alt="101 FSM Detector" width="70%">
                </td>
                </tr>
                </table>
                <hr />
            </div>
        </main>
        <div id="footer-container"></div>
    </div>
    <script>
            fetch('../components/footer-general_en.html')
                .then(response => response.text())
                .then(data => {
                    document.getElementById('footer-container').innerHTML = data;
                });
    </script>
</body>
</html>
